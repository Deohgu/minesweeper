{"ast":null,"code":"const getNeighbouringBlankCells = (neighbouringCellIndexes, updatedCellArray, initialIndex) => neighbouringCellIndexes.filter(neighbourIndex => updatedCellArray[neighbourIndex].advancedChecked !== true && updatedCellArray[neighbourIndex].value !== \"bomb\" && neighbourIndex !== initialIndex);\nconst intersection = (listOne, listTwo) => {\n  const listOneSet = new Set(listOne);\n  const listTwoSet = new Set(listTwo);\n  const _intersection = new Set();\n  for (const element of listTwoSet) {\n    if (listOneSet.has(element)) {\n      _intersection.add(element);\n    }\n  }\n  return [..._intersection];\n};\nexport const mineCheck = (currentIndex, initialIndex, cellArrayCopy, gridColumnsAmount, gridLength) => {\n  const onTheNorthernWall = currentIndex % gridColumnsAmount === 0;\n  const onTheWesternWall = currentIndex === 0;\n  const onTheSouthWesternWall = currentIndex === gridLength - gridColumnsAmount;\n  const onTheEasternWall = currentIndex % gridColumnsAmount === gridColumnsAmount - 1;\n  const onTheNorthEasternWall = currentIndex === gridColumnsAmount - 1;\n  const onTheSouthEasternWall = currentIndex === gridLength - 1;\n  const onTheSouthernWall = currentIndex > gridLength - gridColumnsAmount && currentIndex < gridLength - 1;\n  const directionIndexes = {\n    north: currentIndex - gridColumnsAmount,\n    east: currentIndex + 1,\n    south: currentIndex + gridColumnsAmount,\n    west: currentIndex - 1,\n    get northEast() {\n      return this.north + 1;\n    },\n    get southEast() {\n      return this.south + 1;\n    },\n    get southWest() {\n      return this.south - 1;\n    },\n    get northWest() {\n      return this.north - 1;\n    }\n  };\n  const neighbouringCells = {\n    noWall: [directionIndexes.north, directionIndexes.northEast, directionIndexes.east, directionIndexes.southEast, directionIndexes.south, directionIndexes.southWest, directionIndexes.west, directionIndexes.northWest],\n    northernWall: [directionIndexes.east, directionIndexes.southEast, directionIndexes.south, directionIndexes.southWest, directionIndexes.west],\n    easternWall: [directionIndexes.north, directionIndexes.south, directionIndexes.southWest, directionIndexes.west, directionIndexes.northWest],\n    southernWall: [directionIndexes.north, directionIndexes.northEast, directionIndexes.east, directionIndexes.west, directionIndexes.northWest],\n    westernWall: [directionIndexes.north, directionIndexes.northEast, directionIndexes.east, directionIndexes.southEast, directionIndexes.south],\n    get northEasternWall() {\n      return intersection(this.northernWall, this.easternWall);\n    },\n    get southEasternWall() {\n      return intersection(this.southernWall, this.easternWall);\n    },\n    get southWesternWall() {\n      return intersection(this.southernWall, this.westernWall);\n    },\n    get northWesternWall() {\n      return intersection(this.northernWall, this.westernWall);\n    }\n  };\n  let bombCounter = 0;\n  if (onTheNorthernWall) {\n    if (onTheWesternWall) {\n      // Top Left Corner\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.northWesternWall;\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach(neighbourIndex => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true; // Will be skipped in the future\n      });\n\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        // filters indexes that will advance to check next\n        const neighbouringBlankCells = getNeighbouringBlankCells(neighbouringCellIndexes, cellArrayCopy, initialIndex);\n\n        // Recursion, calls the mineCheck to do the same to the next indexes\n        neighbouringBlankCells.forEach(curr => {\n          return mineCheck(curr, initialIndex, cellArrayCopy, gridColumnsAmount, gridLength);\n        });\n      }\n    } else if (onTheSouthWesternWall) {\n      // Bottom Left Corner\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.southWesternWall;\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach(neighbourIndex => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true;\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        const neighbouringBlankCells = getNeighbouringBlankCells(neighbouringCellIndexes, cellArrayCopy, initialIndex);\n        neighbouringBlankCells.forEach(curr => {\n          return mineCheck(curr, initialIndex, cellArrayCopy, gridColumnsAmount, gridLength);\n        });\n      }\n    } else {\n      // Left Wall\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.westernWall;\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach(neighbourIndex => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true;\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        const neighbouringBlankCells = getNeighbouringBlankCells(neighbouringCellIndexes, cellArrayCopy, initialIndex);\n        neighbouringBlankCells.forEach(curr => {\n          return mineCheck(curr, initialIndex, cellArrayCopy, gridColumnsAmount, gridLength);\n        });\n      }\n    }\n  } else if (onTheEasternWall) {\n    if (onTheNorthEasternWall) {\n      // Top Right Corner\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.northEasternWall;\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach(neighbourIndex => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true;\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        const neighbouringBlankCells = getNeighbouringBlankCells(neighbouringCellIndexes, cellArrayCopy, initialIndex);\n        neighbouringBlankCells.forEach(curr => {\n          return mineCheck(curr, initialIndex, cellArrayCopy, gridColumnsAmount, gridLength);\n        });\n      }\n    } else if (onTheSouthEasternWall) {\n      // Bottom Right Corner\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.southEasternWall;\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach(neighbourIndex => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true;\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        const neighbouringBlankCells = getNeighbouringBlankCells(neighbouringCellIndexes, cellArrayCopy, initialIndex);\n        neighbouringBlankCells.forEach(curr => {\n          return mineCheck(curr, initialIndex, cellArrayCopy, gridColumnsAmount, gridLength);\n        });\n      }\n    } else {\n      // Right Wall\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.easternWall;\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach(neighbourIndex => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true;\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        const neighbouringBlankCells = getNeighbouringBlankCells(neighbouringCellIndexes, cellArrayCopy, initialIndex);\n        neighbouringBlankCells.forEach(curr => {\n          return mineCheck(curr, initialIndex, cellArrayCopy, gridColumnsAmount, gridLength);\n        });\n      }\n    }\n  } else if (currentIndex > 0 && currentIndex < gridColumnsAmount - 1) {\n    // Top Wall strictly\n    if (cellArrayCopy[currentIndex].flagged !== true) {\n      cellArrayCopy[currentIndex].advancedChecked = true;\n    }\n    const neighbouringCellIndexes = neighbouringCells.northernWall;\n    bombCounter = 0;\n    neighbouringCellIndexes.forEach(neighbourIndex => {\n      cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n      cellArrayCopy[neighbourIndex].checked = true;\n    });\n    if (bombCounter > 0) {\n      cellArrayCopy[currentIndex].value = bombCounter;\n    } else {\n      const neighbouringBlankCells = getNeighbouringBlankCells(neighbouringCellIndexes, cellArrayCopy, initialIndex);\n      neighbouringBlankCells.forEach(curr => {\n        return mineCheck(curr, initialIndex, cellArrayCopy, gridColumnsAmount, gridLength);\n      });\n    }\n  } else if (onTheSouthernWall) {\n    // Bottom Wall strictly\n    if (cellArrayCopy[currentIndex].flagged !== true) {\n      cellArrayCopy[currentIndex].advancedChecked = true;\n    }\n    const neighbouringCellIndexes = neighbouringCells.southernWall;\n    bombCounter = 0;\n    neighbouringCellIndexes.forEach(neighbourIndex => {\n      cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n      cellArrayCopy[neighbourIndex].checked = true;\n    });\n    if (bombCounter > 0) {\n      cellArrayCopy[currentIndex].value = bombCounter;\n    } else {\n      const neighbouringBlankCells = getNeighbouringBlankCells(neighbouringCellIndexes, cellArrayCopy, initialIndex);\n      neighbouringBlankCells.forEach(curr => {\n        return mineCheck(curr, initialIndex, cellArrayCopy, gridColumnsAmount, gridLength);\n      });\n    }\n  } else {\n    if (cellArrayCopy[currentIndex].flagged !== true) {\n      cellArrayCopy[currentIndex].advancedChecked = true;\n    }\n    // Not against the wall\n    const neighbouringCellIndexes = neighbouringCells.noWall;\n    bombCounter = 0;\n    neighbouringCellIndexes.forEach(curr => {\n      cellArrayCopy[curr].value === \"bomb\" && bombCounter++;\n      cellArrayCopy[curr].checked = true;\n    });\n    if (bombCounter > 0) {\n      cellArrayCopy[currentIndex].value = bombCounter;\n    } else {\n      const neighbouringBlankCells = getNeighbouringBlankCells(neighbouringCellIndexes, cellArrayCopy, initialIndex);\n      neighbouringBlankCells.forEach(curr => {\n        return mineCheck(curr, initialIndex, cellArrayCopy, gridColumnsAmount, gridLength);\n      });\n    }\n  }\n  return cellArrayCopy;\n};","map":{"version":3,"names":["getNeighbouringBlankCells","neighbouringCellIndexes","updatedCellArray","initialIndex","filter","neighbourIndex","advancedChecked","value","intersection","listOne","listTwo","listOneSet","Set","listTwoSet","_intersection","element","has","add","mineCheck","currentIndex","cellArrayCopy","gridColumnsAmount","gridLength","onTheNorthernWall","onTheWesternWall","onTheSouthWesternWall","onTheEasternWall","onTheNorthEasternWall","onTheSouthEasternWall","onTheSouthernWall","directionIndexes","north","east","south","west","northEast","southEast","southWest","northWest","neighbouringCells","noWall","northernWall","easternWall","southernWall","westernWall","northEasternWall","southEasternWall","southWesternWall","northWesternWall","bombCounter","flagged","forEach","checked","neighbouringBlankCells","curr"],"sources":["/Users/diogosantos/dev/minesweeper/client/src/utils/BoardUtils/mineCheck.ts"],"sourcesContent":["import { CellType, initialStateTypes } from \"../../store/settingsSlice\";\n\nconst getNeighbouringBlankCells = (\n  neighbouringCellIndexes: number[],\n  updatedCellArray: CellType[],\n  initialIndex: number\n) =>\n  neighbouringCellIndexes.filter(\n    (neighbourIndex) =>\n      updatedCellArray[neighbourIndex].advancedChecked !== true &&\n      updatedCellArray[neighbourIndex].value !== \"bomb\" &&\n      neighbourIndex !== initialIndex\n  );\n\nconst intersection = (listOne: any[], listTwo: any[]): any[] => {\n  const listOneSet = new Set(listOne);\n  const listTwoSet = new Set(listTwo);\n\n  const _intersection = new Set();\n  for (const element of listTwoSet) {\n    if (listOneSet.has(element)) {\n      _intersection.add(element);\n    }\n  }\n\n  return [..._intersection];\n};\n\nexport const mineCheck = (\n  currentIndex: number,\n  initialIndex: number,\n  cellArrayCopy: initialStateTypes[\"cellArray\"],\n  gridColumnsAmount: initialStateTypes[\"gridColumnsAmount\"],\n  gridLength: initialStateTypes[\"gridLength\"]\n): initialStateTypes[\"cellArray\"] => {\n  const onTheNorthernWall = currentIndex % gridColumnsAmount === 0;\n  const onTheWesternWall = currentIndex === 0;\n  const onTheSouthWesternWall = currentIndex === gridLength - gridColumnsAmount;\n  const onTheEasternWall =\n    currentIndex % gridColumnsAmount === gridColumnsAmount - 1;\n  const onTheNorthEasternWall = currentIndex === gridColumnsAmount - 1;\n  const onTheSouthEasternWall = currentIndex === gridLength - 1;\n  const onTheSouthernWall =\n    currentIndex > gridLength - gridColumnsAmount &&\n    currentIndex < gridLength - 1;\n\n  const directionIndexes = {\n    north: currentIndex - gridColumnsAmount,\n    east: currentIndex + 1,\n    south: currentIndex + gridColumnsAmount,\n    west: currentIndex - 1,\n    get northEast() {\n      return this.north + 1;\n    },\n    get southEast() {\n      return this.south + 1;\n    },\n    get southWest() {\n      return this.south - 1;\n    },\n    get northWest() {\n      return this.north - 1;\n    },\n  };\n\n  const neighbouringCells = {\n    noWall: [\n      directionIndexes.north,\n      directionIndexes.northEast,\n      directionIndexes.east,\n      directionIndexes.southEast,\n      directionIndexes.south,\n      directionIndexes.southWest,\n      directionIndexes.west,\n      directionIndexes.northWest,\n    ],\n    northernWall: [\n      directionIndexes.east,\n      directionIndexes.southEast,\n      directionIndexes.south,\n      directionIndexes.southWest,\n      directionIndexes.west,\n    ],\n    easternWall: [\n      directionIndexes.north,\n      directionIndexes.south,\n      directionIndexes.southWest,\n      directionIndexes.west,\n      directionIndexes.northWest,\n    ],\n    southernWall: [\n      directionIndexes.north,\n      directionIndexes.northEast,\n      directionIndexes.east,\n      directionIndexes.west,\n      directionIndexes.northWest,\n    ],\n    westernWall: [\n      directionIndexes.north,\n      directionIndexes.northEast,\n      directionIndexes.east,\n      directionIndexes.southEast,\n      directionIndexes.south,\n    ],\n    get northEasternWall(): number[] {\n      return intersection(this.northernWall, this.easternWall);\n    },\n    get southEasternWall(): number[] {\n      return intersection(this.southernWall, this.easternWall);\n    },\n    get southWesternWall(): number[] {\n      return intersection(this.southernWall, this.westernWall);\n    },\n    get northWesternWall(): number[] {\n      return intersection(this.northernWall, this.westernWall);\n    },\n  };\n\n  let bombCounter = 0;\n\n  if (onTheNorthernWall) {\n    if (onTheWesternWall) {\n      // Top Left Corner\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.northWesternWall;\n\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach((neighbourIndex) => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true; // Will be skipped in the future\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        // filters indexes that will advance to check next\n        const neighbouringBlankCells = getNeighbouringBlankCells(\n          neighbouringCellIndexes,\n          cellArrayCopy,\n          initialIndex\n        );\n\n        // Recursion, calls the mineCheck to do the same to the next indexes\n        neighbouringBlankCells.forEach((curr) => {\n          return mineCheck(\n            curr,\n            initialIndex,\n            cellArrayCopy,\n            gridColumnsAmount,\n            gridLength\n          );\n        });\n      }\n    } else if (onTheSouthWesternWall) {\n      // Bottom Left Corner\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.southWesternWall;\n\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach((neighbourIndex) => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true;\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        const neighbouringBlankCells = getNeighbouringBlankCells(\n          neighbouringCellIndexes,\n          cellArrayCopy,\n          initialIndex\n        );\n\n        neighbouringBlankCells.forEach((curr) => {\n          return mineCheck(\n            curr,\n            initialIndex,\n            cellArrayCopy,\n            gridColumnsAmount,\n            gridLength\n          );\n        });\n      }\n    } else {\n      // Left Wall\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.westernWall;\n\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach((neighbourIndex) => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true;\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        const neighbouringBlankCells = getNeighbouringBlankCells(\n          neighbouringCellIndexes,\n          cellArrayCopy,\n          initialIndex\n        );\n\n        neighbouringBlankCells.forEach((curr) => {\n          return mineCheck(\n            curr,\n            initialIndex,\n            cellArrayCopy,\n            gridColumnsAmount,\n            gridLength\n          );\n        });\n      }\n    }\n  } else if (onTheEasternWall) {\n    if (onTheNorthEasternWall) {\n      // Top Right Corner\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.northEasternWall;\n\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach((neighbourIndex) => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true;\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        const neighbouringBlankCells = getNeighbouringBlankCells(\n          neighbouringCellIndexes,\n          cellArrayCopy,\n          initialIndex\n        );\n\n        neighbouringBlankCells.forEach((curr) => {\n          return mineCheck(\n            curr,\n            initialIndex,\n            cellArrayCopy,\n            gridColumnsAmount,\n            gridLength\n          );\n        });\n      }\n    } else if (onTheSouthEasternWall) {\n      // Bottom Right Corner\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.southEasternWall;\n\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach((neighbourIndex) => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true;\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        const neighbouringBlankCells = getNeighbouringBlankCells(\n          neighbouringCellIndexes,\n          cellArrayCopy,\n          initialIndex\n        );\n\n        neighbouringBlankCells.forEach((curr) => {\n          return mineCheck(\n            curr,\n            initialIndex,\n            cellArrayCopy,\n            gridColumnsAmount,\n            gridLength\n          );\n        });\n      }\n    } else {\n      // Right Wall\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.easternWall;\n\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach((neighbourIndex) => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true;\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        const neighbouringBlankCells = getNeighbouringBlankCells(\n          neighbouringCellIndexes,\n          cellArrayCopy,\n          initialIndex\n        );\n\n        neighbouringBlankCells.forEach((curr) => {\n          return mineCheck(\n            curr,\n            initialIndex,\n            cellArrayCopy,\n            gridColumnsAmount,\n            gridLength\n          );\n        });\n      }\n    }\n  } else if (currentIndex > 0 && currentIndex < gridColumnsAmount - 1) {\n    // Top Wall strictly\n    if (cellArrayCopy[currentIndex].flagged !== true) {\n      cellArrayCopy[currentIndex].advancedChecked = true;\n    }\n    const neighbouringCellIndexes = neighbouringCells.northernWall;\n\n    bombCounter = 0;\n\n    neighbouringCellIndexes.forEach((neighbourIndex) => {\n      cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n      cellArrayCopy[neighbourIndex].checked = true;\n    });\n    if (bombCounter > 0) {\n      cellArrayCopy[currentIndex].value = bombCounter;\n    } else {\n      const neighbouringBlankCells = getNeighbouringBlankCells(\n        neighbouringCellIndexes,\n        cellArrayCopy,\n        initialIndex\n      );\n\n      neighbouringBlankCells.forEach((curr) => {\n        return mineCheck(\n          curr,\n          initialIndex,\n          cellArrayCopy,\n          gridColumnsAmount,\n          gridLength\n        );\n      });\n    }\n  } else if (onTheSouthernWall) {\n    // Bottom Wall strictly\n    if (cellArrayCopy[currentIndex].flagged !== true) {\n      cellArrayCopy[currentIndex].advancedChecked = true;\n    }\n    const neighbouringCellIndexes = neighbouringCells.southernWall;\n\n    bombCounter = 0;\n\n    neighbouringCellIndexes.forEach((neighbourIndex) => {\n      cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n      cellArrayCopy[neighbourIndex].checked = true;\n    });\n    if (bombCounter > 0) {\n      cellArrayCopy[currentIndex].value = bombCounter;\n    } else {\n      const neighbouringBlankCells = getNeighbouringBlankCells(\n        neighbouringCellIndexes,\n        cellArrayCopy,\n        initialIndex\n      );\n\n      neighbouringBlankCells.forEach((curr) => {\n        return mineCheck(\n          curr,\n          initialIndex,\n          cellArrayCopy,\n          gridColumnsAmount,\n          gridLength\n        );\n      });\n    }\n  } else {\n    if (cellArrayCopy[currentIndex].flagged !== true) {\n      cellArrayCopy[currentIndex].advancedChecked = true;\n    }\n    // Not against the wall\n    const neighbouringCellIndexes = neighbouringCells.noWall;\n\n    bombCounter = 0;\n\n    neighbouringCellIndexes.forEach((curr) => {\n      cellArrayCopy[curr].value === \"bomb\" && bombCounter++;\n      cellArrayCopy[curr].checked = true;\n    });\n\n    if (bombCounter > 0) {\n      cellArrayCopy[currentIndex].value = bombCounter;\n    } else {\n      const neighbouringBlankCells = getNeighbouringBlankCells(\n        neighbouringCellIndexes,\n        cellArrayCopy,\n        initialIndex\n      );\n\n      neighbouringBlankCells.forEach((curr) => {\n        return mineCheck(\n          curr,\n          initialIndex,\n          cellArrayCopy,\n          gridColumnsAmount,\n          gridLength\n        );\n      });\n    }\n  }\n\n  return cellArrayCopy;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}