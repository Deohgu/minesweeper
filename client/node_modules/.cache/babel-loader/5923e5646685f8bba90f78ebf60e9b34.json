{"ast":null,"code":"import _toConsumableArray from\"/Users/diogosantos/dev/minesweeper/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _createForOfIteratorHelper from\"/Users/diogosantos/dev/minesweeper/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";var getNeighbouringBlankCells=function getNeighbouringBlankCells(neighbouringCellIndexes,updatedCellArray,initialIndex){return neighbouringCellIndexes.filter(function(neighbourIndex){return updatedCellArray[neighbourIndex].advancedChecked!==true&&updatedCellArray[neighbourIndex].value!==\"bomb\"&&neighbourIndex!==initialIndex;});};var intersection=function intersection(listOne,listTwo){var listOneSet=new Set(listOne);var listTwoSet=new Set(listTwo);var _intersection=new Set();var _iterator=_createForOfIteratorHelper(listTwoSet),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var element=_step.value;if(listOneSet.has(element)){_intersection.add(element);}}}catch(err){_iterator.e(err);}finally{_iterator.f();}return _toConsumableArray(_intersection);};export var mineCheck=function mineCheck(currentIndex,initialIndex,cellArrayCopy,gridColumnsAmount,gridLength){var onTheNorthernWall=currentIndex%gridColumnsAmount===0;var onTheWesternWall=currentIndex===0;var onTheSouthWesternWall=currentIndex===gridLength-gridColumnsAmount;var onTheEasternWall=currentIndex%gridColumnsAmount===gridColumnsAmount-1;var onTheNorthEasternWall=currentIndex===gridColumnsAmount-1;var onTheSouthEasternWall=currentIndex===gridLength-1;var onTheSouthernWall=currentIndex>gridLength-gridColumnsAmount&&currentIndex<gridLength-1;var directionIndexes={north:currentIndex-gridColumnsAmount,east:currentIndex+1,south:currentIndex+gridColumnsAmount,west:currentIndex-1,get northEast(){return this.north+1;},get southEast(){return this.south+1;},get southWest(){return this.south-1;},get northWest(){return this.north-1;}};var neighbouringCells={noWall:[directionIndexes.north,directionIndexes.northEast,directionIndexes.east,directionIndexes.southEast,directionIndexes.south,directionIndexes.southWest,directionIndexes.west,directionIndexes.northWest],northernWall:[directionIndexes.east,directionIndexes.southEast,directionIndexes.south,directionIndexes.southWest,directionIndexes.west],easternWall:[directionIndexes.north,directionIndexes.south,directionIndexes.southWest,directionIndexes.west,directionIndexes.northWest],southernWall:[directionIndexes.north,directionIndexes.northEast,directionIndexes.east,directionIndexes.west,directionIndexes.northWest],westernWall:[directionIndexes.north,directionIndexes.northEast,directionIndexes.east,directionIndexes.southEast,directionIndexes.south],get northEasternWall(){return intersection(this.northernWall,this.easternWall);},get southEasternWall(){return intersection(this.southernWall,this.easternWall);},get southWesternWall(){return intersection(this.southernWall,this.westernWall);},get northWesternWall(){return intersection(this.northernWall,this.westernWall);}};var bombCounter=0;if(onTheNorthernWall){if(onTheWesternWall){// Top Left Corner\nif(cellArrayCopy[currentIndex].flagged!==true){cellArrayCopy[currentIndex].advancedChecked=true;}var neighbouringCellIndexes=neighbouringCells.northWesternWall;bombCounter=0;neighbouringCellIndexes.forEach(function(neighbourIndex){cellArrayCopy[neighbourIndex].value===\"bomb\"&&bombCounter++;cellArrayCopy[neighbourIndex].checked=true;// Will be skipped in the future\n});if(bombCounter>0){cellArrayCopy[currentIndex].value=bombCounter;}else{// filters indexes that will advance to check next\nvar neighbouringBlankCells=getNeighbouringBlankCells(neighbouringCellIndexes,cellArrayCopy,initialIndex);// Recursion, calls the mineCheck to do the same to the next indexes\nneighbouringBlankCells.forEach(function(curr){return mineCheck(curr,initialIndex,cellArrayCopy,gridColumnsAmount,gridLength);});}}else if(onTheSouthWesternWall){// Bottom Left Corner\nif(cellArrayCopy[currentIndex].flagged!==true){cellArrayCopy[currentIndex].advancedChecked=true;}var _neighbouringCellIndexes=neighbouringCells.southWesternWall;bombCounter=0;_neighbouringCellIndexes.forEach(function(neighbourIndex){cellArrayCopy[neighbourIndex].value===\"bomb\"&&bombCounter++;cellArrayCopy[neighbourIndex].checked=true;});if(bombCounter>0){cellArrayCopy[currentIndex].value=bombCounter;}else{var _neighbouringBlankCells=getNeighbouringBlankCells(_neighbouringCellIndexes,cellArrayCopy,initialIndex);_neighbouringBlankCells.forEach(function(curr){return mineCheck(curr,initialIndex,cellArrayCopy,gridColumnsAmount,gridLength);});}}else{// Left Wall\nif(cellArrayCopy[currentIndex].flagged!==true){cellArrayCopy[currentIndex].advancedChecked=true;}var _neighbouringCellIndexes2=neighbouringCells.westernWall;bombCounter=0;_neighbouringCellIndexes2.forEach(function(neighbourIndex){cellArrayCopy[neighbourIndex].value===\"bomb\"&&bombCounter++;cellArrayCopy[neighbourIndex].checked=true;});if(bombCounter>0){cellArrayCopy[currentIndex].value=bombCounter;}else{var _neighbouringBlankCells2=getNeighbouringBlankCells(_neighbouringCellIndexes2,cellArrayCopy,initialIndex);_neighbouringBlankCells2.forEach(function(curr){return mineCheck(curr,initialIndex,cellArrayCopy,gridColumnsAmount,gridLength);});}}}else if(onTheEasternWall){if(onTheNorthEasternWall){// Top Right Corner\nif(cellArrayCopy[currentIndex].flagged!==true){cellArrayCopy[currentIndex].advancedChecked=true;}var _neighbouringCellIndexes3=neighbouringCells.northEasternWall;bombCounter=0;_neighbouringCellIndexes3.forEach(function(neighbourIndex){cellArrayCopy[neighbourIndex].value===\"bomb\"&&bombCounter++;cellArrayCopy[neighbourIndex].checked=true;});if(bombCounter>0){cellArrayCopy[currentIndex].value=bombCounter;}else{var _neighbouringBlankCells3=getNeighbouringBlankCells(_neighbouringCellIndexes3,cellArrayCopy,initialIndex);_neighbouringBlankCells3.forEach(function(curr){return mineCheck(curr,initialIndex,cellArrayCopy,gridColumnsAmount,gridLength);});}}else if(onTheSouthEasternWall){// Bottom Right Corner\nif(cellArrayCopy[currentIndex].flagged!==true){cellArrayCopy[currentIndex].advancedChecked=true;}var _neighbouringCellIndexes4=neighbouringCells.southEasternWall;bombCounter=0;_neighbouringCellIndexes4.forEach(function(neighbourIndex){cellArrayCopy[neighbourIndex].value===\"bomb\"&&bombCounter++;cellArrayCopy[neighbourIndex].checked=true;});if(bombCounter>0){cellArrayCopy[currentIndex].value=bombCounter;}else{var _neighbouringBlankCells4=getNeighbouringBlankCells(_neighbouringCellIndexes4,cellArrayCopy,initialIndex);_neighbouringBlankCells4.forEach(function(curr){return mineCheck(curr,initialIndex,cellArrayCopy,gridColumnsAmount,gridLength);});}}else{// Right Wall\nif(cellArrayCopy[currentIndex].flagged!==true){cellArrayCopy[currentIndex].advancedChecked=true;}var _neighbouringCellIndexes5=neighbouringCells.easternWall;bombCounter=0;_neighbouringCellIndexes5.forEach(function(neighbourIndex){cellArrayCopy[neighbourIndex].value===\"bomb\"&&bombCounter++;cellArrayCopy[neighbourIndex].checked=true;});if(bombCounter>0){cellArrayCopy[currentIndex].value=bombCounter;}else{var _neighbouringBlankCells5=getNeighbouringBlankCells(_neighbouringCellIndexes5,cellArrayCopy,initialIndex);_neighbouringBlankCells5.forEach(function(curr){return mineCheck(curr,initialIndex,cellArrayCopy,gridColumnsAmount,gridLength);});}}}else if(currentIndex>0&&currentIndex<gridColumnsAmount-1){// Top Wall strictly\nif(cellArrayCopy[currentIndex].flagged!==true){cellArrayCopy[currentIndex].advancedChecked=true;}var _neighbouringCellIndexes6=neighbouringCells.northernWall;bombCounter=0;_neighbouringCellIndexes6.forEach(function(neighbourIndex){cellArrayCopy[neighbourIndex].value===\"bomb\"&&bombCounter++;cellArrayCopy[neighbourIndex].checked=true;});if(bombCounter>0){cellArrayCopy[currentIndex].value=bombCounter;}else{var _neighbouringBlankCells6=getNeighbouringBlankCells(_neighbouringCellIndexes6,cellArrayCopy,initialIndex);_neighbouringBlankCells6.forEach(function(curr){return mineCheck(curr,initialIndex,cellArrayCopy,gridColumnsAmount,gridLength);});}}else if(onTheSouthernWall){// Bottom Wall strictly\nif(cellArrayCopy[currentIndex].flagged!==true){cellArrayCopy[currentIndex].advancedChecked=true;}var _neighbouringCellIndexes7=neighbouringCells.southernWall;bombCounter=0;_neighbouringCellIndexes7.forEach(function(neighbourIndex){cellArrayCopy[neighbourIndex].value===\"bomb\"&&bombCounter++;cellArrayCopy[neighbourIndex].checked=true;});if(bombCounter>0){cellArrayCopy[currentIndex].value=bombCounter;}else{var _neighbouringBlankCells7=getNeighbouringBlankCells(_neighbouringCellIndexes7,cellArrayCopy,initialIndex);_neighbouringBlankCells7.forEach(function(curr){return mineCheck(curr,initialIndex,cellArrayCopy,gridColumnsAmount,gridLength);});}}else{if(cellArrayCopy[currentIndex].flagged!==true){cellArrayCopy[currentIndex].advancedChecked=true;}// Not against the wall\nvar _neighbouringCellIndexes8=neighbouringCells.noWall;bombCounter=0;_neighbouringCellIndexes8.forEach(function(curr){cellArrayCopy[curr].value===\"bomb\"&&bombCounter++;cellArrayCopy[curr].checked=true;});if(bombCounter>0){cellArrayCopy[currentIndex].value=bombCounter;}else{var _neighbouringBlankCells8=getNeighbouringBlankCells(_neighbouringCellIndexes8,cellArrayCopy,initialIndex);_neighbouringBlankCells8.forEach(function(curr){return mineCheck(curr,initialIndex,cellArrayCopy,gridColumnsAmount,gridLength);});}}return cellArrayCopy;};","map":{"version":3,"sources":["/Users/diogosantos/dev/minesweeper/src/utils/BoardUtils/mineCheck.ts"],"names":["getNeighbouringBlankCells","neighbouringCellIndexes","updatedCellArray","initialIndex","filter","neighbourIndex","advancedChecked","value","intersection","listOne","listTwo","listOneSet","Set","listTwoSet","_intersection","element","has","add","mineCheck","currentIndex","cellArrayCopy","gridColumnsAmount","gridLength","onTheNorthernWall","onTheWesternWall","onTheSouthWesternWall","onTheEasternWall","onTheNorthEasternWall","onTheSouthEasternWall","onTheSouthernWall","directionIndexes","north","east","south","west","northEast","southEast","southWest","northWest","neighbouringCells","noWall","northernWall","easternWall","southernWall","westernWall","northEasternWall","southEasternWall","southWesternWall","northWesternWall","bombCounter","flagged","forEach","checked","neighbouringBlankCells","curr"],"mappings":"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","sourcesContent":["import { CellType, initialStateTypes } from \"../../store/settingsSlice\";\n\nconst getNeighbouringBlankCells = (\n  neighbouringCellIndexes: number[],\n  updatedCellArray: CellType[],\n  initialIndex: number\n) =>\n  neighbouringCellIndexes.filter(\n    (neighbourIndex) =>\n      updatedCellArray[neighbourIndex].advancedChecked !== true &&\n      updatedCellArray[neighbourIndex].value !== \"bomb\" &&\n      neighbourIndex !== initialIndex\n  );\n\nconst intersection = (listOne: any[], listTwo: any[]): any[] => {\n  const listOneSet = new Set(listOne);\n  const listTwoSet = new Set(listTwo);\n\n  const _intersection = new Set();\n  for (const element of listTwoSet) {\n    if (listOneSet.has(element)) {\n      _intersection.add(element);\n    }\n  }\n\n  return [..._intersection];\n};\n\nexport const mineCheck = (\n  currentIndex: number,\n  initialIndex: number,\n  cellArrayCopy: initialStateTypes[\"cellArray\"],\n  gridColumnsAmount: initialStateTypes[\"gridColumnsAmount\"],\n  gridLength: initialStateTypes[\"gridLength\"]\n): initialStateTypes[\"cellArray\"] => {\n  const onTheNorthernWall = currentIndex % gridColumnsAmount === 0;\n  const onTheWesternWall = currentIndex === 0;\n  const onTheSouthWesternWall = currentIndex === gridLength - gridColumnsAmount;\n  const onTheEasternWall =\n    currentIndex % gridColumnsAmount === gridColumnsAmount - 1;\n  const onTheNorthEasternWall = currentIndex === gridColumnsAmount - 1;\n  const onTheSouthEasternWall = currentIndex === gridLength - 1;\n  const onTheSouthernWall =\n    currentIndex > gridLength - gridColumnsAmount &&\n    currentIndex < gridLength - 1;\n\n  const directionIndexes = {\n    north: currentIndex - gridColumnsAmount,\n    east: currentIndex + 1,\n    south: currentIndex + gridColumnsAmount,\n    west: currentIndex - 1,\n    get northEast() {\n      return this.north + 1;\n    },\n    get southEast() {\n      return this.south + 1;\n    },\n    get southWest() {\n      return this.south - 1;\n    },\n    get northWest() {\n      return this.north - 1;\n    },\n  };\n\n  const neighbouringCells = {\n    noWall: [\n      directionIndexes.north,\n      directionIndexes.northEast,\n      directionIndexes.east,\n      directionIndexes.southEast,\n      directionIndexes.south,\n      directionIndexes.southWest,\n      directionIndexes.west,\n      directionIndexes.northWest,\n    ],\n    northernWall: [\n      directionIndexes.east,\n      directionIndexes.southEast,\n      directionIndexes.south,\n      directionIndexes.southWest,\n      directionIndexes.west,\n    ],\n    easternWall: [\n      directionIndexes.north,\n      directionIndexes.south,\n      directionIndexes.southWest,\n      directionIndexes.west,\n      directionIndexes.northWest,\n    ],\n    southernWall: [\n      directionIndexes.north,\n      directionIndexes.northEast,\n      directionIndexes.east,\n      directionIndexes.west,\n      directionIndexes.northWest,\n    ],\n    westernWall: [\n      directionIndexes.north,\n      directionIndexes.northEast,\n      directionIndexes.east,\n      directionIndexes.southEast,\n      directionIndexes.south,\n    ],\n    get northEasternWall(): number[] {\n      return intersection(this.northernWall, this.easternWall);\n    },\n    get southEasternWall(): number[] {\n      return intersection(this.southernWall, this.easternWall);\n    },\n    get southWesternWall(): number[] {\n      return intersection(this.southernWall, this.westernWall);\n    },\n    get northWesternWall(): number[] {\n      return intersection(this.northernWall, this.westernWall);\n    },\n  };\n\n  let bombCounter = 0;\n\n  if (onTheNorthernWall) {\n    if (onTheWesternWall) {\n      // Top Left Corner\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.northWesternWall;\n\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach((neighbourIndex) => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true; // Will be skipped in the future\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        // filters indexes that will advance to check next\n        const neighbouringBlankCells = getNeighbouringBlankCells(\n          neighbouringCellIndexes,\n          cellArrayCopy,\n          initialIndex\n        );\n\n        // Recursion, calls the mineCheck to do the same to the next indexes\n        neighbouringBlankCells.forEach((curr) => {\n          return mineCheck(\n            curr,\n            initialIndex,\n            cellArrayCopy,\n            gridColumnsAmount,\n            gridLength\n          );\n        });\n      }\n    } else if (onTheSouthWesternWall) {\n      // Bottom Left Corner\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.southWesternWall;\n\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach((neighbourIndex) => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true;\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        const neighbouringBlankCells = getNeighbouringBlankCells(\n          neighbouringCellIndexes,\n          cellArrayCopy,\n          initialIndex\n        );\n\n        neighbouringBlankCells.forEach((curr) => {\n          return mineCheck(\n            curr,\n            initialIndex,\n            cellArrayCopy,\n            gridColumnsAmount,\n            gridLength\n          );\n        });\n      }\n    } else {\n      // Left Wall\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.westernWall;\n\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach((neighbourIndex) => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true;\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        const neighbouringBlankCells = getNeighbouringBlankCells(\n          neighbouringCellIndexes,\n          cellArrayCopy,\n          initialIndex\n        );\n\n        neighbouringBlankCells.forEach((curr) => {\n          return mineCheck(\n            curr,\n            initialIndex,\n            cellArrayCopy,\n            gridColumnsAmount,\n            gridLength\n          );\n        });\n      }\n    }\n  } else if (onTheEasternWall) {\n    if (onTheNorthEasternWall) {\n      // Top Right Corner\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.northEasternWall;\n\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach((neighbourIndex) => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true;\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        const neighbouringBlankCells = getNeighbouringBlankCells(\n          neighbouringCellIndexes,\n          cellArrayCopy,\n          initialIndex\n        );\n\n        neighbouringBlankCells.forEach((curr) => {\n          return mineCheck(\n            curr,\n            initialIndex,\n            cellArrayCopy,\n            gridColumnsAmount,\n            gridLength\n          );\n        });\n      }\n    } else if (onTheSouthEasternWall) {\n      // Bottom Right Corner\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.southEasternWall;\n\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach((neighbourIndex) => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true;\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        const neighbouringBlankCells = getNeighbouringBlankCells(\n          neighbouringCellIndexes,\n          cellArrayCopy,\n          initialIndex\n        );\n\n        neighbouringBlankCells.forEach((curr) => {\n          return mineCheck(\n            curr,\n            initialIndex,\n            cellArrayCopy,\n            gridColumnsAmount,\n            gridLength\n          );\n        });\n      }\n    } else {\n      // Right Wall\n      if (cellArrayCopy[currentIndex].flagged !== true) {\n        cellArrayCopy[currentIndex].advancedChecked = true;\n      }\n      const neighbouringCellIndexes = neighbouringCells.easternWall;\n\n      bombCounter = 0;\n      neighbouringCellIndexes.forEach((neighbourIndex) => {\n        cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n        cellArrayCopy[neighbourIndex].checked = true;\n      });\n      if (bombCounter > 0) {\n        cellArrayCopy[currentIndex].value = bombCounter;\n      } else {\n        const neighbouringBlankCells = getNeighbouringBlankCells(\n          neighbouringCellIndexes,\n          cellArrayCopy,\n          initialIndex\n        );\n\n        neighbouringBlankCells.forEach((curr) => {\n          return mineCheck(\n            curr,\n            initialIndex,\n            cellArrayCopy,\n            gridColumnsAmount,\n            gridLength\n          );\n        });\n      }\n    }\n  } else if (currentIndex > 0 && currentIndex < gridColumnsAmount - 1) {\n    // Top Wall strictly\n    if (cellArrayCopy[currentIndex].flagged !== true) {\n      cellArrayCopy[currentIndex].advancedChecked = true;\n    }\n    const neighbouringCellIndexes = neighbouringCells.northernWall;\n\n    bombCounter = 0;\n\n    neighbouringCellIndexes.forEach((neighbourIndex) => {\n      cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n      cellArrayCopy[neighbourIndex].checked = true;\n    });\n    if (bombCounter > 0) {\n      cellArrayCopy[currentIndex].value = bombCounter;\n    } else {\n      const neighbouringBlankCells = getNeighbouringBlankCells(\n        neighbouringCellIndexes,\n        cellArrayCopy,\n        initialIndex\n      );\n\n      neighbouringBlankCells.forEach((curr) => {\n        return mineCheck(\n          curr,\n          initialIndex,\n          cellArrayCopy,\n          gridColumnsAmount,\n          gridLength\n        );\n      });\n    }\n  } else if (onTheSouthernWall) {\n    // Bottom Wall strictly\n    if (cellArrayCopy[currentIndex].flagged !== true) {\n      cellArrayCopy[currentIndex].advancedChecked = true;\n    }\n    const neighbouringCellIndexes = neighbouringCells.southernWall;\n\n    bombCounter = 0;\n\n    neighbouringCellIndexes.forEach((neighbourIndex) => {\n      cellArrayCopy[neighbourIndex].value === \"bomb\" && bombCounter++;\n      cellArrayCopy[neighbourIndex].checked = true;\n    });\n    if (bombCounter > 0) {\n      cellArrayCopy[currentIndex].value = bombCounter;\n    } else {\n      const neighbouringBlankCells = getNeighbouringBlankCells(\n        neighbouringCellIndexes,\n        cellArrayCopy,\n        initialIndex\n      );\n\n      neighbouringBlankCells.forEach((curr) => {\n        return mineCheck(\n          curr,\n          initialIndex,\n          cellArrayCopy,\n          gridColumnsAmount,\n          gridLength\n        );\n      });\n    }\n  } else {\n    if (cellArrayCopy[currentIndex].flagged !== true) {\n      cellArrayCopy[currentIndex].advancedChecked = true;\n    }\n    // Not against the wall\n    const neighbouringCellIndexes = neighbouringCells.noWall;\n\n    bombCounter = 0;\n\n    neighbouringCellIndexes.forEach((curr) => {\n      cellArrayCopy[curr].value === \"bomb\" && bombCounter++;\n      cellArrayCopy[curr].checked = true;\n    });\n\n    if (bombCounter > 0) {\n      cellArrayCopy[currentIndex].value = bombCounter;\n    } else {\n      const neighbouringBlankCells = getNeighbouringBlankCells(\n        neighbouringCellIndexes,\n        cellArrayCopy,\n        initialIndex\n      );\n\n      neighbouringBlankCells.forEach((curr) => {\n        return mineCheck(\n          curr,\n          initialIndex,\n          cellArrayCopy,\n          gridColumnsAmount,\n          gridLength\n        );\n      });\n    }\n  }\n\n  return cellArrayCopy;\n};\n"]},"metadata":{},"sourceType":"module"}